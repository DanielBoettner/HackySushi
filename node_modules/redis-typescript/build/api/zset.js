"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../core/base");
const tools_1 = require("../util/tools");
var MethodZset;
(function (MethodZset) {
    // bzpopmax
    // bzpopmin
    MethodZset["zadd"] = "ZADD";
    MethodZset["zcard"] = "ZCARD";
    MethodZset["zcount"] = "ZCOUNT";
    MethodZset["zincrby"] = "ZINCRBY";
    MethodZset["zinterstore"] = "ZINTERSTORE";
    MethodZset["zlexcount"] = "ZLEXCOUNT";
    // zpopmax
    // zpopmin
    MethodZset["zrange"] = "ZRANGE";
    MethodZset["zrangebylex"] = "ZRANGEBYLEX";
    MethodZset["zrangebyscore"] = "ZRANGEBYSCORE";
    MethodZset["zrank"] = "ZRANK";
    MethodZset["zrem"] = "ZREM";
    MethodZset["zremrangebylex"] = "ZREMRANGEBYLEX";
    MethodZset["zremrangebyrank"] = "ZREMRANGEBYRANK";
    MethodZset["zremrangebyscore"] = "ZREMRANGEBYSCORE";
    MethodZset["zrevrange"] = "ZREVRANGE";
    // zrevrangebylex
    MethodZset["zrevrangebyscore"] = "ZREVRANGEBYSCORE";
    MethodZset["zrevrank"] = "ZREVRANK";
    // zscan
    MethodZset["zscore"] = "ZSCORE";
    MethodZset["zunionstore"] = "ZUNIONSTORE";
})(MethodZset || (MethodZset = {}));
class RedisZset extends base_1.Base {
    zadd(key, objMS, options = {}) {
        const array = new Array();
        const { nxxx, ch, incr } = options;
        Reflect.ownKeys(objMS).forEach((member) => {
            array.push(objMS[member], member);
        });
        if ("undefined" !== typeof nxxx) {
            if ("undefined" !== typeof ch) {
                if ("undefined" !== typeof incr) {
                    return this.command(MethodZset.zadd, key, nxxx, ch, incr, ...array);
                }
                else {
                    return this.command(MethodZset.zadd, key, nxxx, ch, ...array);
                }
            }
            else if ("undefined" !== typeof incr) {
                return this.command(MethodZset.zadd, key, nxxx, incr, ...array);
            }
            else {
                return this.command(MethodZset.zadd, key, nxxx, ...array);
            }
        }
        else if ("undefined" !== typeof ch) {
            if ("undefined" !== typeof incr) {
                return this.command(MethodZset.zadd, key, ch, incr, ...array);
            }
            else {
                return this.command(MethodZset.zadd, key, ch, ...array);
            }
        }
        else if ("undefined" !== typeof incr) {
            return this.command(MethodZset.zadd, key, incr, ...array);
        }
        else {
            return this.command(MethodZset.zadd, key, ...array);
        }
    }
    zcard(key) {
        return this.command(MethodZset.zcard, key);
    }
    zcount(key, min, max) {
        return this.command(MethodZset.zcount, key, min, max);
    }
    zincrby(key, increment, member) {
        return this.command(MethodZset.zincrby, key, increment, member);
    }
    zinterstore(destination, objectKW, aggregate = "SUM") {
        const keys = new Array();
        const weights = new Array();
        Reflect.ownKeys(objectKW).forEach((key) => {
            keys.push(key);
            weights.push(objectKW[key]);
        });
        return this.command(MethodZset.zinterstore, destination, keys.length, ...keys, "WEIGHTS", ...weights, "AGGREGATE", aggregate);
    }
    zlexcount(key, min, max) {
        return this.command(MethodZset.zlexcount, key, min, max);
    }
    zrange(key, start, stop, withscores) {
        return __awaiter(this, void 0, void 0, function* () {
            if ("WITHSCORES" === withscores) {
                return tools_1.Array2Object(yield this.command(MethodZset.zrange, key, start, stop, "WITHSCORES"));
            }
            return this.command(MethodZset.zrange, key, start, stop);
        });
    }
    zrangebylex(key, min, max, options) {
        if ("object" === typeof options) {
            return this.command(MethodZset.zrangebylex, key, min, max, "LIMIT", options.offset, options.count);
        }
        return this.command(MethodZset.zrangebylex, key, min, max);
    }
    zrangebyscore(key, min, max, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if ("object" === typeof options.limit) {
                const { offset, count } = options.limit;
                if ("WITHSCORES" === options.withscores) {
                    return tools_1.Array2Object(yield this.command(MethodZset.zrangebyscore, key, min, max, "WITHSCORES", "LIMIT", offset, count));
                }
                else {
                    return this.command(MethodZset.zrangebyscore, key, min, max, "LIMIT", offset, count);
                }
            }
            else if ("WITHSCORES" === options.withscores) {
                return tools_1.Array2Object(yield this.command(MethodZset.zrangebyscore, key, min, max, "WITHSCORES"));
            }
            else {
                return this.command(MethodZset.zrangebyscore, key, min, max);
            }
        });
    }
    zrank(key, member) {
        return this.command(MethodZset.zrank, key, member);
    }
    zrem(key, member, ...members) {
        return this.command(MethodZset.zrem, key, member, ...members);
    }
    zremrangebylex(key, min, max) {
        return this.command(MethodZset.zremrangebylex, key, min, max);
    }
    zremrangebyrank(key, start, stop) {
        return this.command(MethodZset.zremrangebyrank, key, start, stop);
    }
    zremrangebyscore(key, min, max) {
        return this.command(MethodZset.zremrangebyscore, key, min, max);
    }
    zrevrange(key, start, stop, withscores) {
        return __awaiter(this, void 0, void 0, function* () {
            if ("WITHSCORES" === withscores) {
                return tools_1.Array2Object(yield this.command(MethodZset.zrevrange, key, start, stop, "WITHSCORES"));
            }
            else {
                return this.command(MethodZset.zrevrange, key, start, stop);
            }
        });
    }
    zrevrangebyscore(key, max, min, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if ("object" === typeof options.limit) {
                const { offset, count } = options.limit;
                if ("WITHSCORES" === options.withscores) {
                    return tools_1.Array2Object(yield this.command(MethodZset.zrevrangebyscore, key, max, min, "WITHSCORES", "LIMIT", offset, count));
                }
                else {
                    return this.command(MethodZset.zrevrangebyscore, key, max, min, "LIMIT", offset, count);
                }
            }
            else if ("WITHSCORES" === options.withscores) {
                return tools_1.Array2Object(yield this.command(MethodZset.zrevrangebyscore, key, max, min, "WITHSCORES"));
            }
            else {
                return this.command(MethodZset.zrevrangebyscore, key, max, min);
            }
        });
    }
    zrevrank(key, member) {
        return this.command(MethodZset.zrevrank, key, member);
    }
    zscore(key, member) {
        return this.command(MethodZset.zscore, key, member);
    }
    zunionstore(destination, objectKW, aggregate = "SUM") {
        const keys = new Array();
        const weights = new Array();
        Reflect.ownKeys(objectKW).forEach((key) => {
            keys.push(key);
            weights.push(objectKW[key]);
        });
        return this.command(MethodZset.zunionstore, destination, keys.length, ...keys, "WEIGHTS", ...weights, "AGGREGATE", aggregate);
    }
}
exports.RedisZset = RedisZset;
//# sourceMappingURL=zset.js.map