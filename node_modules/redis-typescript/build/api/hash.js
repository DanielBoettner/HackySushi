"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../core/base");
const tools_1 = require("../util/tools");
var MethodHash;
(function (MethodHash) {
    MethodHash["hdel"] = "HDEL";
    MethodHash["hexists"] = "HEXISTS";
    MethodHash["hget"] = "HGET";
    MethodHash["hgetall"] = "HGETALL";
    MethodHash["hincrby"] = "HINCRBY";
    MethodHash["hincrbyfloat"] = "HINCRBYFLOAT";
    MethodHash["hkeys"] = "HKEYS";
    MethodHash["hlen"] = "HLEN";
    MethodHash["hmget"] = "HMGET";
    MethodHash["hmset"] = "HMSET";
    MethodHash["hscan"] = "HSCAN";
    MethodHash["hset"] = "HSET";
    MethodHash["hsetnx"] = "HSETNX";
    MethodHash["hstrlen"] = "HSTRLEN";
    MethodHash["hvals"] = "HVALS";
})(MethodHash || (MethodHash = {}));
class RedisHash extends base_1.Base {
    hdel(key, field, ...fields) {
        return this.command(MethodHash.hdel, key, field, ...fields);
    }
    hexists(key, field) {
        return this.command(MethodHash.hexists, key, field);
    }
    hget(key, field) {
        return this.command(MethodHash.hget, key, field);
    }
    hgetall(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return tools_1.Array2Object(yield this.command(MethodHash.hgetall, key));
        });
    }
    hincrby(key, field, increment) {
        return this.command(MethodHash.hincrby, key, field, increment);
    }
    hincrbyfloat(key, field, increment) {
        return this.command(MethodHash.hincrbyfloat, key, field, increment);
    }
    hkeys(key) {
        return this.command(MethodHash.hkeys, key);
    }
    hlen(key) {
        return this.command(MethodHash.hlen, key);
    }
    hmget(key, field, ...fields) {
        return this.command(MethodHash.hmget, key, field, ...fields);
    }
    hmset(key, hash) {
        const arrayFV = new Array();
        Reflect.ownKeys(hash).forEach((field) => {
            arrayFV.push(field, hash[field]);
        });
        return this.command(MethodHash.hmset, key, ...arrayFV);
    }
    hset(key, field, value) {
        return this.command(MethodHash.hset, key, field, value);
    }
    hsetnx(key, field, value) {
        return this.command(MethodHash.hsetnx, key, field, value);
    }
    hstrlen(key, field) {
        return this.command(MethodHash.hstrlen, key, field);
    }
    hvals(key) {
        return this.command(MethodHash.hvals, key);
    }
}
exports.RedisHash = RedisHash;
//# sourceMappingURL=hash.js.map