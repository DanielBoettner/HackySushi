"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../core/base");
var MethodString;
(function (MethodString) {
    MethodString["set"] = "SET";
    MethodString["get"] = "GET";
    MethodString["getrange"] = "GETRANGE";
    MethodString["getset"] = "GETSET";
    MethodString["getbit"] = "GETBIT";
    MethodString["mget"] = "MGET";
    MethodString["setbit"] = "SETBIT";
    MethodString["setex"] = "SETEX";
    MethodString["setnx"] = "SETNX";
    MethodString["setrange"] = "SETRANGE";
    MethodString["strlen"] = "STRLEN";
    MethodString["mset"] = "MSET";
    MethodString["msetnx"] = "MSETNX";
    MethodString["psetex"] = "PSETEX";
    MethodString["incr"] = "INCR";
    MethodString["incrby"] = "INCRBY";
    MethodString["incrbyfloat"] = "INCRBYFLOAT";
    MethodString["decr"] = "DECR";
    MethodString["decrby"] = "DECRBY";
    MethodString["append"] = "APPEND";
})(MethodString || (MethodString = {}));
class RedisString extends base_1.Base {
    append(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.append, key, value));
        });
    }
    decr(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.decr, key));
        });
    }
    decrby(key, increment) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.decrby, key, increment));
        });
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.get, key));
        });
    }
    getbit(key, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.getbit, key, offset));
        });
    }
    getrange(key, [start, end] = [0, -1]) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.getrange, key, start, end));
        });
    }
    getset(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.getset, key, value));
        });
    }
    incr(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.incr, key));
        });
    }
    incrby(key, increment) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.incrby, key, increment));
        });
    }
    incrbyfloat(key, increment) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.incrbyfloat, key, increment));
        });
    }
    mget(key, ...keys) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.mget, key, ...keys));
        });
    }
    mset(objKV) {
        return __awaiter(this, void 0, void 0, function* () {
            const arrayKV = new Array();
            Reflect.ownKeys(objKV).forEach((key) => {
                arrayKV.push(key, objKV[key]);
            });
            return (yield this.command(MethodString.mset, ...arrayKV));
        });
    }
    msetnx(objKv) {
        return __awaiter(this, void 0, void 0, function* () {
            const arrayKV = new Array();
            Reflect.ownKeys(objKv).forEach((key) => {
                arrayKV.push(key, objKv[key]);
            });
            return (yield this.command(MethodString.msetnx, ...arrayKV));
        });
    }
    psetex(key, milliseconds, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.psetex, key, milliseconds, value));
        });
    }
    set(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.set, key, value));
        });
    }
    setbit(key, offset, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.setbit, key, offset, value));
        });
    }
    setex(key, seconds, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.setex, key, seconds, value));
        });
    }
    setnx(key, ...keys) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.setnx, key, ...keys));
        });
    }
    setrange(key, offset, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.setrange, key, offset, value));
        });
    }
    strlen(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.command(MethodString.strlen, key));
        });
    }
}
exports.RedisString = RedisString;
//# sourceMappingURL=string.js.map